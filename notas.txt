estas son las notas del curso de desarrollo web full-stack , iniciaremos con laravel y su instalacion 

QUE ES UNA API 

una api es una interfaz de programacion de aplicaciones, basicamente es un conjunto de rutinas y funciones 
esta permite que los productos se comuniquen con otros sin necesidad de saber como estan implementados 
esto permite algo asi como el desarrollo de una aplicacion que se comunique con el backend sin afectar el front-end ni el cliente 


REST es una interfaz de programacion entre sistemas que use el protocolo http para obtener datos o generar operaciones con lo mismo 

La API REST siempre es independiente del tipo de plataformas o lenguajes: 
la API REST siempre se adapta al tipo de sintaxis o plataformas con las que se estén trabajando, 
lo que ofrece una gran libertad a la hora de cambiar o probar nuevos entornos dentro del desarrollo.
 Con una API REST se pueden tener servidores PHP, Java, Python o Node.js. Lo único que es indispensable es que las 
 respuestas a las peticiones se hagan siempre en el lenguaje de intercambio de información usado, 
 normalmente XML o JSON.


usaremos composer el cual es un manejador de paquetes de php, este nos permitira descargar laravel y mantener 
el framework actualizado 

ES INDISPENSABLE TENER COMPOSER PARA USAR LARAVEL, EN SU DOCUMENTACION LO REQUIERE 

es muy sencillo solo debemos descargar el archivo ejecutable y seguir los pasos

debemos usar la consola de comandos cmd o el git bash e ingresar el siguiente comando, segun la documentacion de laravel 
hay varios dependiendo del modo que se quiera crear 

esta composer global require laravel/instaler 

tambien esta composer create-proyect laravel/laravel -nombre de proyecto- y la version que queremos 
en este proyecto y de ahora en adelante aprenderemos esta version 

el comando final seria composer create-proyect laravel/laravel -nombre-proyecto- "*"
si lo ponemos de esta forma, nos descarara la version de laravel mas actual, en este momento es la version 5.8
en este caso usaremos esa version 
comproser create-project laravel/laravel api-rest-blog "5.7.*" de esta manera ejecutamos el codigo 

luego de ejecutar el codigo se ejecuta una descarga, esta creara una carpeta que tendra el nombre del proyecto 

nos descarga una serie de carpetas. usando el framework de boostrap, en la  carpeta public encontraremos el index.php

si creamos una api con lavarel, estaremos trabajando en la carpeta app 


por lo que he visto del curso, usaremos el modelo vista controlador para el desarrollo de la api 


en la carpeta routes, encontraremos las rutas que usaremos. la mas usada sera web 

en la carpeta resources, encontraremos las vistas. 

CREAR UN HOST VIRTUAL PARA TRABAJAR CON LARAVEL 
este paso lo haremos con el fin de no tener que escribir toda la url completa, si no, escribir algo mas similar a una url de un sitio web 
C:\wamp\bin\apache\apache2.4.9\conf\extra\httpd-vhosts.conf  debemos seguir esta ruta 

<VirtualHost *:80>   
    DocumentRoot "${INSTALL_DIR}/htdocs/apiblog/api-blog/public"
    ServerName api-blog.com.devel
    ServerAlias www.api-blog.com.devel
    <Directory "${INSTALL_DIR}/htdocs/apiblog/api-blog/public">
        Options Indexes FollowSymLinks     
        AllowOverride All
        Order Deny,Allow
        Allow from all     
    </Directory> 
</VirtualHost> 

el devel hace referencia a desarrollo 

luego de hacer todo esto, debemos entrar a al archivo host en sytem32 etc, ejecutamos como administrador y agregamos la url 

127.0.0.1       localhost
127.0.0.1   zend2.com.devel

Lo que le estamos indicando es que cuando carguemos cualquiera de esos dominios nos llame a la IP que le indicamos en este caso 127.0.0.1 en lugar de la IP original del dominio si es que la tiene.

seguido a eso reiniciamos el server local 
 
CREAR UNA RUTA 
para crear una ruta entramos al archivo route,en el archivo web. usamos la palabra reservada Route:: luego usamos el protocolo http que queramos 


Route::get('/prueba', function(){
    return "<p> lo que queramos </p>";
});

de esta manera hacemos que se presente ese parrafo, como podemos ver esta nos regresa una funcion anonima 


pasar valor a la url. lo hacemos de esta manera, debemos agregarle las llaves y poner el parametro, adicionar a eso debemos psarle el parametro a la funcion 


Route::get('/prueba/{nombre}', function($nombre){
    return " <p> Nombre: {$nombre} </p>";
});

ahora bien, al pasarle el parametro a la url y la funcion, es indispensable pasarle un valor. en caso que no se haga. esto nos dara un error 
si lo hacems pues nos retorna el nombre o lo que hayamos puesto, agregandole un ? al lado del parametro dew la url {nombre?} de esta manera, esta se volvera opcional 
solo debemos poner el parametro de la funcion un valor por defecto  function($nombre = null)

nosotros podemos vincular una vista a una ruta o una accion del controlador  

para crear una vista debemos usar, el nombre del archivo.blade.php, blade es el motor de plantillas de laravel 


Route::get('/pruebas/{nombre}', function($nombre){

    $nombreVariable = "<p> Nombre: {$nombre} </p>";

    return view('prueba', array(
        'texto' => $nombreVariable
    )); 
});
de esta manera le pasamos los valores al metodo view, no se imprime nada directamente en la ruta.

ES INDISPENSABLE QUE EL NOMBRE DE LA LLAVE Y EL NOMBRE DE LA VARIABLE SEAN EL MISMO. SI NO ES ASI DARA UN ERROR QUE 
LA VARIABLE NO ESTA DEFINIDA

las cosas siempre  se deben imrpimir en la vista, sea que venga desde un controlador o lo que sea 



CREAR UN CONTROLADOR EN LARAVEL
es recomendable usar la consola de comandos para crear un controlador, ejecutaremos el siguiente codigo 
php artisan make:controller nombreControler
artisan es la consola de comandos de laravel, es recomendable que se especifique la palabra controller en el documento ya que esto nos ayudara
los controladores los encontramos en  app/http/controllers/

MOSTRAR UN CONTROLADOR 
al usar una ruta, es como si especificaramos una url que esta usara

 en este ejemplo usaremos un metodo, este retornara a una vista. la url de la vista es una carpeta dentro de ellas, y separamos el fichero con un punto 

public function Index(){
       $titulo = "Autos"; 
       
       $marcas = ['perro', 'gato', 'delfin'];

       return view('pruebas.index');
    }

recuerda que al usar el mvc, las vistas es donde presentmos todo, el controlador es el que se encarga DE RECIBIR TODOS LOS datos del mismo 
y el modelo es donde esta toda la logica de negcio 

en el momento de usar alguna variable que se represente en el controlador. y mostrarla en las vistas, debemos usar {{}} doble llave 
recuerda que al pasar algo a la vista, debemos enviarle datos con un array. de la siguiente manera 

public function Index(){
       $titulo = "Autos"; 
       
       $marcas = ['perro', 'gato', 'delfin'];

       return view('pruebas.index', array(
           'titulo' => $titulo, 
           'marcas' => $marcas
       ));
    }

este ejemplo es una funcion en el controlador, que sera pasada a una vista, en el return, como podemos ver, debemos especificar la ruta de la vista 
aparte de eso debemos pasarle los valores en un array. las llaves del array deben ser exactamente iguales a el nombre de las variables 

nota: el forEach en lavarel se usa @forEach 

para presentar o "crear una pagina" desde un controlador. lo hacemos de esta manera
Route::get('/animales', 'pruebaControlador@Index');

DESARROLLO DE LA API 
antes que nada, debemos diseñr la base de datos. esto nos ayudara con el desarollo, para lo mismpo podemos usar un programa llamado dia 

luego de descargado debemos empezar a diseñar las tablas. 

nota: es indispensable en las tablas de usuario que manejaremos con lavavel. que creememos tres tablas aparte de las que ya tenemos diseñadas 
estas son: createAt. esta nos guardara la fecha en la que fue creado el usuario 
updateAt. la fecha en la cual fue actualizado el usuario 
y por ultimo remeberToken. es para en caso de usar la autenticacion de laravel. este guarda un token para recordar al usuario

al estar creando las tablas, debemos crear las relaciones inmediatamente 
Primary key(id)
foreign key (fk_idcategories) references Categories(id),
foreign key (fk_idusers) references Users(id)

de esta manera 


luego de crear la base de datos, para conectarla al proyecto de laravel. debemos abrir el archivo .env este nos mostrara todas las opciones de conexion 

DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=api_blog
DB_USERNAME=
DB_PASSWORD=

  


CREAR UN MODELO 
el modelo en el mvc es el que tiene la logica de negocio. debemos crar un modelo por cada tabla de la base de datos 
para crear un modelo debemos usar artisan, de igual forma a como creamos un controlador 
php artisan make:model nombreModelo


al crear un modelo debemos especificar la tabla a la que esta asignada y debemos establecer la relaciones entre ellos 

protected $table = 'posts'; de esta manera establecemos el nombre de la tabla. 

public function User(){
    return $this->belongsTo('App\User', 'fk_iduser');
}

asi establecemos la relacion, en este caso de muchos a uno, cuando es ese el caso debemos agregar la fk 

 public function Posts(){
        return $this->hasMany('App/Post'); //de esta manera especificamos la relacion con el modelo post
 }
 y asi es de muchos a uno, no hay que agregar otro parametro 



 MOSTRAR INFORMACION DE LA BASE DE datos

pasar usar los modelos en el controlador debemos llamarlos 
use App\Categories;
use App\Posts;
especificamos la carpeta de dodne se encuentran y los llamamos


        //creamos una varialbe con lo que nos traemos de post por ejemplo, esto nos retornara un array 
        //debemos especificar la variable que sea diferente a alguna ya usada por el el lenguaje, luego llamamos la clase. 
        //al usar los dos puntos como en este caso, podemos acceder a sus metodos. esto nos devuelve un array como antes dije 
        $posts = Posts::all(); 
        
        foreach($posts as $post){
            echo "<p>{$post}</p>";
        }
        
        die(); 

    }

   luego de todo crea una ruta, indispensable para poder visualizar el resultado 

   gracias a la relacion que hemos generado con las funciones, podemos acceder a varialbles de otros modelos
   como lo hacemos. ya que especificamos las variables. debeos acceder a los metodos de relacion, ya sea de 
   uno a muchos o de muchos a uno. usamos el nombre y luego el campo que queremos obtener 

   como vemos en el ejercicio de arriba estamos accediendo al modelo Posts 
   echo "<p>{$post->user->name}</p>"; y de esta forma podemos traer la informacion de usuario accediendo a el metodo que conecta Posts con user 
   y accedemos al campo que queremos 

   cuando haces un $categories = Categories::all(); lo que te trae es un array de metodos aparte de los que tu creaste 
   cuando haces un foreach, solo retorna los que tu creaste pero igual te retorna un array con toda la informacion de la tabla de l base de dato
   por lo cual debes acceder al valor que necesitas 

   foreach ($categories as $value) {
            echo "<h1> {$value->name} </h1>"; 
aqui hay un ejemplo 

cuando vayas a hacer una relacion. especifica el id del mismo aparte debemos especificar la llave foreanea en la funcion 
hasMany, ya que en caso de no hacerlo. esto solo nos traera un resultado por cada llave foranea 



CONTROLADORES, RUTAS Y HTTP 
controlador: parte que se enarga de recibir datos desde las vistas 

debemos crear un controlador por cada modelo, estoos se escargaran en el caso del usuario, de registrar las entradas y 
todo lo relacionado.. luego de crear un controlador al crear una funcion en el mismo, es necesario pasarle un objeto Request 
una una variable $request, si no. no podemos pasarle datos ni peticiones 

RECUERDA SIEMPRE CREAR UNA RUTA DEL CONTROLADOR 

es recomendable que cuando se cree rutas desde la api, se usen rutas como Route::post('/api/lo que se vaya a hacer')

una rest es full cuando se usan los 4 metodos http mas comunes 
post: insertar o guardar datos desde un formulario 
get: obtener datos
put: actualizar datos o recursos 
delete: borrar los datos o recursos 



USAR POSTMAN O UN CLIENTE RESTFULL
si no queremos usar la proteccion que inclue laravel para los formularios, debemos comentarla 
lo encontramos en kernel         //\App\Http\Middleware\VerifyCsrfToken::class.. esto solo pasa con post 

si queremos usar el cliente rest debemos copiar la ruta que especificamos y usar el metodo que especificamos, si intentamos visualizar la ruta en el 
navegador nos arrojara este error 
http://apiblog.com.devel/api/register la ruta 
The GET method is not supported for this route. Supported methods: POST. este error nos muestra porque estamos intentado acceder a una ruta que usa el metodo post 
por get 


con postman podemos mandarle datos como simulando un formulario. en ese caso. debemos hacer lo siguiente 
debemos tener en cuenta que el objeto request tiene todos los datos que el cliente envia, por lo cual debemos acceder a los atributos del objeto 

de esta manera sacamos la informacion que se nos envia 
$name = $request->input('name'); en este caso sacamos el nombre debemos tener en cuenta que el controlador es el que recibe los parametros del cliente 
por eso lo hacemos ahi, ademas de eso. tener encuenta que en input, se ingresa la llave que este nos envie 

LISTAR LAS RUTAS DEL PROYECTO 
podemos usar artisan para eso, debemos usar la consola. php artisan route:list 
eso nos retornara una tabla con todas las rutas 

+--------+----------+-------------------+------+-----------------------------------------------------------+--------------+
| Domain | Method   | URI               | Name | Action                                                    | Middleware   |
+--------+----------+-------------------+------+-----------------------------------------------------------+--------------+
|        | GET|HEAD | /                 |      | Closure                                                   | web          |
|        | POST     | api/login         |      | App\Http\Controllers\userController@login                 | web          |
|        | POST     | api/register      |      | App\Http\Controllers\userController@registro              | web          |
|        | GET|HEAD | api/user          |      | Closure                                                   | api,auth:api |
|        | GET|HEAD | categorias/prueba |      | App\Http\Controllers\categoriesController@pruebaCategorie | web          |
|        | GET|HEAD | post/prueba       |      | App\Http\Controllers\postsController@pruebaPost           | web          |
|        | GET|HEAD | test              |      | App\Http\Controllers\pruebaController@pruebaoms           | web          |
|        | GET|HEAD | usuario/prueba    |      | App\Http\Controllers\userController@pruebaUser            | web          |
+--------+----------+-------------------+------+-----------------------------------------------------------+--------------+

de esta manera 



como hicimos en el proyecto anterior, recuerda que a js le pasabamos un array que convertiamos a json y este array contenia una respuesta 
aqui haremos exactamente lo mismo, crearemos un array con el estado, el codigo http y un mensaje 

es muy sencillo hacer un json con laravel, debemos usar el metodo response() adicionar a eso debemos usar json() dentro de el debemos pasarle el paramreto 
que en este caso es el array y aarte debemos pasarle el codigo http que queramos 

$respuesta = array(
            'estado' => 'completo', 
            'codigo' => 200, 
            'descripcion' => 'el resgistro se realizo correctamente'
        );

return response()->json($respuesta, $respuesta['codigo']);
de esta manera retornamos un json 

los passos para crear un usuario basicamente siempre sera los mismos. recibir los datos del post, validarlos, verificar el usuario duplicado
cifrar la contraseña, crear el usuario y esperar respuesta 

recuerda que el front-end nos enviara los requerimientos en un json, por lo cual se debe recibir los datos de esta manera. decodificarlos

los recibimos igual con la instancia de request, este recibe dos parametros, la llave que debe tener el json y el default que es nulo ..

$params = json_decode($json); //de esta manera nos retorna un objeto, si le agregamos el paramtro true, nos retorna un array 


validar en laravel, para validar en laravel podemos usar una una libreria llamada Validate 

se ejecuta de la siguiente manera $validate = \Validator::make($params [
            
        ]);

este recibe dos parametros, el primer parametro es un array que queremos validar. el segundoson los campos que queremos validar.
de la siguiente manera.

$validate = \Validator::make($params, [
            'name'       => 'require|alpha',
            'lastName'   => 'require|alpha',
            'userName'   => 'require|alpha',
            'email'      => 'require|email',
            'password'   => 'require'
]);

de esta manera validamos si los campos son validos usando las reglas de validacion del objeto Validator, las podemos encontrar en 
https://laravel.com/docs/5.8/validation

de esta manera damos respuesta en caso de no validar los campos

        if($validate->fails()){
            return response()->json($validate->errors(), 400);
        }

para agregar mas seguridad podemos usar un array_map, este nos retorna un arrany luego de pasar pir una funcion que hayamos aplicado 

en este caso usaremos trim. con el fn de evitar que haya algun elemento o espacio delante de los array 

luego de validar esto, ciframos la contraseña, podemos usar el metodo password_hash()

comprobar usuario duplicado, 
en si usaramos php en este caso tendriamos que hacer una consulta a la base de datos usando sql. en laravel podemos aprovechar omr del mismo 
usando una de las reglas de validacion que en este caso sea unique pero debemos agregarle como minimo la tabla donde debe ser unica 

para crear el usuario debemos llamar el modelo de usuarios con el use
seguido a eso debemos instanciar un objeto del mismo y asi agregarle los parametros necesarios 

por ultimo para guardar los datos en la misma. solo debemos darle save

las fechas las mete automaticamente laravel por medio del orm 

NOTA. es indispensble que created_at y updated_at tengan estos nombres en la base de datos o reemplacemos los nombres en modelo de 
eloquen. ademas updated_at registra el cambio primero por lo cual es indispensable que esta este primero 
el nombre de los campos no son relevantes ya que se puede cambiar pero, si el orden de los mismos 


INSTALAR JWT 
JWT json web token, una libreria que este este metodo. crea un token cuando el usuario haga un login se genere un token con la autenticacion de ese token 
el token servira para autenticar, esto es como un seccion. si el cliente quiere ver cierta parte del front-end la patecion debe llevar este token 
este token tendra los datos relevantes. si el token es valido, el usuario estara registrado correctamente 

usaremos firebase para hacer esto 

para instalarla debemos abrir composer.json, en require (aqui agregamos las librerias a intalar)

debemos agregarla "firebase/php-jwt": "5.0.0" 5.0 es la version de la misma 

luego vamos a la consola y lanzamos el comando composer update, actualizar las dependencias obsoletas e instala 
las que no estan 

este metodo es muy seguro ya que en base a los datos del usuario, se crean tokens y si queremos estar autenticados
se estara enviando el token en las cabezeras y lo decodificaremos en el back-end y tendremos una clave unica que solo tendra la parsona que desarrolla 


USAR JWT 
debemos crear una carpeta helpers en la base de la app,
creamos un archivo, le damos un namespaces y llamamos los siguientes archivos

use Firebase\JWT\JWT; usar la libreria de jwt 
use Illuminate\Support\Facades\DB; conectar a la base de datos y hacer consultas y agregamos el modelo de usuario obviamente 

creamos la clase seguimos una serie de pasos 

//buscar si existe el usuario y contraseña 

//comprobar si existen 

//generar el token con los datos del usuario identificado 

//devolver los datos decodificados o el token en funcion de un parametro 

pero antes que nada debemos crear un provider. para incrustar la nueva clase en el framework 
igual que un modelo y un controlador usamos artisan 
luego de crear el mismo, debemos ingresar y agregarle esta linea en el metodo register 
include_once app_path().'/helpers/jwtAuth.php';

seguido a eso debemos ir a config/app.php y registrar el provider  App\Providers\JwtAuthServicesProvider::class, de esta manera. si queremos le creamos 
un alias asi comoo el de Validator o similares 
'JwtAuth' => App\helpers\jwtAuth::class, de esta manera

luego de hacer esto. podemos ya usarlo en el controlador que deseemos usar 

es necesario agregar el alias para poder llamarla 

porque creamos un provider?. lo podemos encontrar en este link 
https://programacionymas.com/blog/service-providers-en-laravel

Los service providers se encargan de toda la configuración necesaria antes de empezar a usar un servicio.
Dependiendo del servicio que se va a iniciar, el proveedor se encarga de crear nuevas instancias y posiblemente las relaciones con otros servicios 
(definir parámetros, oyentes de eventos, middlewares, rutas).


luego de hacer todo esto ahora si podemos darle funcionalidad a la funcion de signUp en el helper en jwtAuth 

le pasamos dos parametros que serian el nombre de usuario y contraseña ademas de eso debemos pasarle algo mas. que seria el token en caso de estar logeado ya 
por defecto sera null 

hacemos una consulta a la base de datos usando el modelo usuario User::where. esto nos hara una consulta a la base de datos pero debemos pasarle un array 
con los datos que queremos $user = User::where([  el first nos traera el primer objeto que se muestre 
                                    'userName' => $userName,
                                    'password' => $password
                                    ])->first();

seguido a eso debemos validar si existe, esto es usando un if, si $user es un objeto entoces este existe. unicializamos la variable en false para evitar problemas 
luego a eso creamos el token. podemos usar la documentacio de la libreria que encontramos aqui https://github.com/firebase/php-jwt

luego retornamos los datos en funcion del parametro  
if(is_null($getToken)){
    $data = $jwt;
}else{
    $data =$jwtDecode ;
}


luego de eso pasamos al controlador. hacemos los mismos pasos que en login, tomamos los datos que llegan en json, los convertimos en un array, validams que no esten vacios 
seguido a eso lo valimados con validator, creamos la respuesta en caso de algun error, instanciamos el objeto jwt 
usamos el metodo signUp. le pasamos los parametros necesarios. seguido a eso, en caso de recibir el token. retornamos la informacion de la base de datos
si nos retorna el token, se lo pasamos al cliente y este nos lo retornara para validar la sesion  

SIEMPRE QUE SAQUES ALGO D UNA FUNCION EN EL CONTROLADOR, RECUERDA VOLVERLA UN JSON 



CREAR UN METODO PARA VALIDAR LOS TOKENS 

en este punto ya hemos creado el token y se lo hemos enviado al cliente. ahora este nos lo retorna, debemos validar que el token que nos retorna el cliente es correcto

creamos una funcion en el helper de jwt esta recibe dos parametros, una es el token creado y la otra es un parametro qu e inicializamos en false 
mas adelante veremos porque

creamos una variable que por defecto estara en false, la variable sera la que usemos para validar el token, o sea el token a este momento es ffalso 
los tokens al crearse se le añaden comillas, debemos quitarselas. podemos usar replace. seguido a eso, usamos un try ya que esta parte del codigo puede traer algunos errores 

try {

 $tokenDeco = JWT::decode($jwt, $this->key, ['HS256']); 
} catch (\UnexpectedValueException $th) {
    $auth = false;
}catch (\DomainException $th) {
    $auth = false;
}

seguido validamos el token, si es un objeto. no esta vacio y ademas tiene un id valido, lo validamos, en caso que no. pues no

ademas debemos RETORNAR los valores 

tambien hacer la validacion, en caso que el segundo argumento de la funcion sea true, devolvemos el token decodificado 



ACTUALIZAR USUARIO

recuerda crear la ruta, usando el metodo http put 

el token, nos lo estara pasando el cliente por la cabecera por lo cual tomaremos del objeto request. el header 
lo almacenamos en una variable, seguido a eso instanciamos una clase de jwt, que es nuestor helper, usamos el metodo antes mensionado para validar el token

si la funcion nos retorna true (el token de usuario es valido).

recibimos y convertimos el json que nos lleva en un array 

RECUERDA QUE LLEGAN EN JSON  asi que hay que que decoficicarlo, creamos un array apartir de eso, lo validamos usando validate. seguido a eso 
en este punto, nos puede dar un error ya que validaremos datos unicos como el email y el username 
para actualizarlos debemos pasar por alto eso, asi que debemos usar una regla llamada unique, se implementa de la sigueinte manera. debemos pasarle las reglas de validacion 
pero al momento de validar que sea unica en cierta tabla, debemos hacer lo que veremos a continuacion

'userName'   => ['required', Rule::unique('users')->ignore($usuarioToken->sub)]
creamos un array pasandole todas las reglas de validacion luego usamos la clase Rule en el link que dejare abajo encontraremos toda la informacion 

https://laravel.com/docs/5.8/validation

decodificamos el token y pasamos como segundo paramentro true, ya que como recuerdas. la funcion para validar el token si vamos a validar y evitar que nos de error 
por elementos similares debemos pasarle o concatenar el sub o id que el token tiene desde el momento en que lo creamos

en caso de recibir un parametro adiciconal como true, esto nos retorna los datos del usuario  si la verificacion es valida iniciaos el proceso de recibir los datos. 



removemos los ccampos del array que no queramos actualizar. usamos la funcion unset y le pasamos el parametro que no queremos luego de podemos actualizar los datos 
eso lo hacemos primero creando una variable. llamando al modelo usuario usando el metodo where al cual debemos pasarle el id, debe ser igual a como esta en la db y la etiqueta 
que nos trae la informacion del token decodificada 

ya luego de eso pues retornamos la respuesta 
como validacion adicional podemos ponerle que solo ejecute el codigo si el json que recibimos no esta vacio. aparte de solo recibir el token 
RECUERDA QUE AL HACER ACTUALIZACIONES DEBEMOS USAR EL METODO HTTP PUT 



ACTUALIZAR FOTO
desarrollamos un metodo para esto, como en casos anteriores, el usuario debe estar autenticado. por lo cual requeriremos que este nos envie el token, recibir el cuerpo del mismo 
etc. para evitar realizar algunos pasos que puede llegar a ser repetitivos, podemos usar middlewares. ahora veremos que es. 
debemos crearlo como creamos un controlador o algo similar usando artinsa 

primero definamos que es un middleware

Un middleware es un mecanismo que se utiliza para filtrar las peticiones HTTP en una aplicación. 
Están disponibles desde la versión 5 de Laravel y te permiten agregar capas adicionales a la lógica de tu aplicación.
El ejemplo mas común de un Middleware es el de autenticación. Este nos serviría, por ejemplo, en un sitio en donde es necesario iniciar sesión y tener ciertos privilegios para poder ver el contenido de determinadas páginas

podemos tomarlo que es como un filtro, que se ejecutrara antes de ejecutar alguna accion del controlador 

luego de esto, podemos crealo ya definitivamente, luego de crearlo lo encontraremos en la carpeta app/http/middleware

al middleware los datos que le pasaremos seran, la seccion donde recibimos el token desde el header, la seccion donde instanciamos la clase jwr y llamamos al metodo 
el middleware por si mismo es una funcion. esta retorna (return $next($request);) en este caso como pasamos a validar si el token es correcto o no
podemos hacer lo sigioente 

 if ($verificarToken) {
            return $next($request);
         } else {
             
            $data = array(
                'estado' => 'error',
                'codigo' => 400,
                'mensaje'=> 'ocurrio un error'
            );

            return response()->json($data, $data['codigo']);
         }
pero eso no es todo, tambien debemos registarlo en la configuracion, en el kernel, lo podemos registrar de varias formas, para si poder usarlo. pero 
una de la formas mas sencillas de usar es por medio de una ruta, buscamos $routemiddleware y lo agregamos ahi 
'apiauth' => \App\Http\Middleware\ApiAuthMiddleware::class de esta manera

ahora para poder usarlo, lo agregamos desde la ruta que creamos, en este caso en el ejemplo de subir una foto, lo agregamos luego de la ruta 

https://laravel.com/docs/5.8/middleware#assigning-middleware-to-routes aqui encontrarems mas informacion, debemos recordar que debemos pasar el nombre de la clase 
por si acaso no nos funciona. si este es el caso y debemos agregar el namespace de la clase, al momento de llamar el middleware. debemos especificar que es una clase 
->middleware(CheckAge::class); de esta manera 

RECUERDA PASARLE AL Middleware LOS DATOS DE LA CLASE DEL TOKEN SI LOS USARAS 


los middleware son alguna especia de 'acortadores de codigo' ya que en algunos casos se pueden usar para tareas repetitivas y tambien sirven de filtro 
en caso de alguna accion 


bueno luego de crear el middleware podemos empezar con la funcion para subir la foto, en este caso como estaremos manejando archivos. usaremos en vez de request imput 
usaremos file. este metodo nos retorna una instancia de una clase que nos brinda mas metodos para poder interactual con el mismo 

https://laravel.com/docs/5.8/requests#files toda la informacion sobre implementarlos la encntraremos aqui, 

en la funcion lo que haremos sera tomar el archivo usando file. el front-end nos enviara un nombre de archivo especifico. depedendo de las librerias que usaremos

validaremos si hay una foto o no. en caso de haberla. creamos una variable y usamos el metodo time() este nos dara una fecha unica. ademas le concatenamos 
el nombre real de la foto, esto lo optenemos usando un metodo llamado  ->getClientOriginalName(); 

luego de eso. preparamos el almaceamiento. laravel nos suministra una forma de almacenarlo, es algo 'metodo' que se da por medio de discos 

Dentro de este archivo puede configurar todos sus "discos". Cada disco representa un controlador de almacenamiento y una ubicación de almacenamiento en particular. Las configuraciones de ejemplo para cada controlador compatible se incluyen en el archivo de configuración. 
Por lo tanto, modifique la configuración para reflejar sus preferencias y credenciales de almacenamiento. podemops encontrar mas informacion en este link 
https://laravel.com/docs/5.8/filesystem#file-uploads 

para poder usar los discos primero debemos configurarlos. eso lo hacemos en el archivo filesystem 
cada 'disco' representa un controlador de almacenamiento y una ubicacion en particular 
para este proyecto, configuraremos dos. una para la foto de los ususarios y otro para las imagenes del las entradas 

debemos entrar al la carpeta de configuracion al archivo de filesystem. debemos crear las carpetas de configuracion, para eso solo debemos 
copiar el storage publico que hay ahi. solo debemos cambiarle el nombre y la ruta a la misma. normalmente es storage\app\nombre 

'users' => [
            'driver' => 'local',
            'root' => storage_path('app/users'),
            'url' => env('APP_URL').'/storage',
            'visibility' => 'public',
        ],
aqui tenemos un ejemplo,luego de crearlo en el archivo creamos las carpetas en la ruta storage app 
en este caso ya tenemos los 'discos' ahora los usaremos 

ahora debemos insertar la imagen a la cual le hemos pasamos los datos de la fecha y el nombre de la misma. debemos usar dos metodos que nos suministra laravel
primer debemos llamar a la clase Storage. de ahi debemos llamar el metodo put. este nos insertara el contenido en la carpeta o 'disco' que hemos creado 
tambien debemos llamar el metodo disk de esta manera Storage::disk('disco donde guardaremos)->put('llave, conteneido)

$imageName = time().$image->getClientOriginalName(); 
            \Storage::disk('users')->put($imageName, \FILE::GET($image));

aqui tenemos un ejemplo debemos especificar el disco donde sera guardado, al pasarle el archivo que pasaremos. usando put 
recibe dos parametros. el primero es un nombre o llave diria yo  y el segundo es el archivo en si, a este accedemos usando el objeto File::get 

Nota: al usar postman. si queremos pasarle un archivo al documento, usamos en el body, form-data. esta nos da la opcion de enviar fotos 

al vliente enviar la foto, esta nos lo guardara donde hayamos deseado, en este caso es de manera local con "discos" que creamos. pero lo podemos hacer con 
almacenamiento en la nube si queremos


para agregar mas seguridad debemos validar que sea realmente una imagen lo que subimos. usamos el metodo Validator para eso 
lo hacemos de la manera en la que ya hemos hecho. pero esta vez usaremos una regla llamada image 

nunca podremos negar un objeto o validador, esto no hara nada. en este caso lo validamos de la siguiente manera 
if(!$image || $validate->fails()){
            
    $data = array(
        'estado' => 'error',
        'codigo' => 400,
        'mensaje' => 'no hay imagen disponible'
    );


OPTENER IMAGEN 

haremos una funcion para retornar la imagen, sera algo simple. la funcion recibira como parametro el nombre del archivo, 

verificamos si existe, para eso el Objeto storage tiene un metodo, especificamos el disco donde debe estar la imagen aparte usamos exists()
dentro ponemos el nombre del archivo, esto obviamente nos retornara una respuesta. en caso de ser afirmativo, ejecutamos el codigo para llamar Storage 
especificamos el disco donde esta guardado el mismo y en vez de usar put para lamacenarlo, usaremos get. $file = \Storage::disk('users')->get($imagen); de esta manera 
recuerda almacenarlo en una variable 

pase bastante tiempo buscando en la documentacion de laravel si podia usar response()->file() y al usarlo note que este acepta la ruta del archiv. asi que si le pasas el archivo en si. te dara un error 
si queremos retornar la imagen, debemos usar el objeto Response(), le pasamos como parametros, la imagen y el codigo del mismo. la respuesta de este debemos meterlo en una etiqueta img 




SACAR INFORMACION DEL USUARIO

igual lo haremos como el metodo de sacar la foto, recibiremos un id como parametro. y buscaremos usando el metodo find. este recibe como parametro el id 
es como si hiciera User::where('id' => $id)->first();

en cambio con find es mucho mas sencillo, solo es User::find($id); seguido a eso pues ya es algo qu debemos verificar si es un objeto
en caso de serlo pues enviar la informacion que requerimos. si no enviar un mensaje de error 

Nota: cuando se crea un proyecto con laravel podemos elegir los campos que sean visibles y los campos que permaneceran ocultos en el modelo 




CATEGORIAS 


